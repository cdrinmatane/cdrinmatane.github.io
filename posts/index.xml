<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on CDRIN Research Blog</title><link>https://cdrinmatane.github.io/blog-hugo/posts/</link><description>CDRIN Research Blog (Posts)</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 11 May 2023 09:48:54 -0400</lastBuildDate><atom:link href="https://cdrinmatane.github.io/blog-hugo/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>SSAO using Visibility Bitmasks</title><link>https://cdrinmatane.github.io/blog-hugo/posts/ssaovb-code/</link><pubDate>Thu, 11 May 2023 09:48:54 -0400</pubDate><guid>https://cdrinmatane.github.io/blog-hugo/posts/ssaovb-code/</guid><description>&lt;!---
```csharp
// dirSign: 1 -> sampling right side of the slice
// -1 -> sampling left side of the slice
// pos: position of current pixel
// angleVtoN: angle from V to N
// return: GI (RGB), AO (A)
float4 SampleDir(float dirSign, float3 pos, float3 viewDir, float angleVtoN, float thickness)
{
uint bitmaskSlice = 0;
float4 GIAO = 0;
for (uint i = 0; i &lt; sampleCount; i++)
{
float3 frontPos = GetSamplePos(pos, i);
float3 frontDir = frontPos - pos;
// Find backface dir by moving of thickness along -viewDir
float3 backDir = frontDir - viewDir * thickness;
// Project sample onto the unit circle and compute the angle relative to viewDir
float2 angles = float2(dot(normalize(frontDir), viewDir), dot(normalize(backDir), viewDir));
angles = FastAcos(angles);
// Shift slice from viewDir to normal, clamp in [0..1]
angles = saturate(((dirSign * -angles) - angleVtoN + HALF_PI) / PI);
// Sampling direction inverts min/max angles
angles = dirSign > 0 ? angles.yx : angles.xy;
uint bitmask = OccludeSectors(angles.x, angles.y);
GIAO.rgb += ComputeGI(bitmask, bitmaskSlice, frontPos);
bitmaskSlice |= bitmask;
}
GIAO.rgb += ComputeAmbient(bitmaskSlice, normal, thickness);
GIAO.a = ComputeAO(bitmaskSlice);
return GIAO;
}
```
```csharp
uint OccludeSectors(float minAngle, float maxAngle){
uint startAngle = minAngle * NUM_SECTOR;
float angle = round((maxAngle-minAngle) * NUM_SECTOR);
return uint(exp2(angle)-1) &lt;&lt; startAngle;
}
```
```csharp
float ComputeAO(uint bf){
return 1.0 - float(countbits(bf)) / NUM_SECTOR;
}
```
```csharp
float3 ComputeAmbient(uint bf, float3 T, float3 N){
uint subRegionSize = NUM_SECTOR / NUM_SAMPLE;
uint mask = exp2(subRegionSize) - 1;
float3 light = 0;
for (float i = 0; i &lt; NUM_SAMPLE; i++){
float hits = subRegionSize - countbits(bf &amp; mask);
// Generate a ray centered in the subregion
float a = lerp(0, PI, (i + 0.5) / NUM_SAMPLE);
float3 dir = normalize(T * cos(a) + N * sin(a));
light += SampleAmbient(dir) * hits / NUM_SECTOR;
bf >>= size;
}
return light;
```
```csharp
float3 ComputeGI(uint bf, uint bfSlice, float3 samplePos,
float3 pixelToSample, float3 N){
// Compute the number of newly occluded sectors only
float hits = countbits(bf &amp; (~bfSlice));
if(hits > 0){
float3 l = SampleLightTexture(samplePos.xy);
float3 L = normalize(pixelToSample);
float NDotL = saturate(dot(N, L));
// Continue if light is facing surface normal
if(NDotL > 0.0){
float3 Ln = GetNormal(samplePos.xy);
float LnDotL = saturate(dot(Ln, -L));
return hits / NUM_SECTOR * l * NDotL * LnDotL;
}
}
return 0;
}
```
-->
&lt;p>We recently released the paper &lt;a href="https://arxiv.org/abs/2301.11376">Screen Space Indirect Lighting with Visibility Bitmask&lt;/a>, a rendering technique based on GTAO that replaces the two horizon angles by a bit field representing the binary state (occluded / un-occluded) of N sectors uniformly distributed around the hemisphere slice. It allows light to pass behind surfaces of constant thickness while keeping the efficiency of horizon-based methods.&lt;/p>
&lt;p>We wanted to share some HLSL code to make it easier to implement in a 3D applications and clarify some details from the paper. Here we take the Unity GTAO code from HDRP as a starting point, to show that our method can be integrated in an existing implementation with only a few modifications.&lt;/p>
&lt;p>The GTAO algorithm starts by taking a fixed number (&lt;em>dirCount&lt;/em>) of random directions per pixel (&lt;em>dir&lt;/em>). Then a 2D circular slice is defined with the following parametrization:&lt;/p>
&lt;ul>
&lt;li>&lt;em>V&lt;/em>: The view direction (direction from current pixel to camera)&lt;/li>
&lt;li>&lt;em>normalVS&lt;/em>: The view-space normal at the current pixel&lt;/li>
&lt;li>&lt;em>sliceN&lt;/em>: Unit vector that is perpendicular to the slice plane&lt;/li>
&lt;li>&lt;em>projN&lt;/em>: The normal projected onto the slice plane (the normal is almost never aligned with the slice plane)&lt;/li>
&lt;li>&lt;em>T&lt;/em>: The slice tangent (perpendicular to &lt;em>V&lt;/em> and &lt;em>sliceN&lt;/em>)&lt;/li>
&lt;li>&lt;em>N&lt;/em>: The angle in radians from &lt;em>V&lt;/em> to &lt;em>projN&lt;/em>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-hlsl" data-lang="hlsl">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> integral &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float3&lt;/span> V &lt;span style="color:#f92672">=&lt;/span> normalize(&lt;span style="color:#f92672">-&lt;/span>positionVS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> dirCount; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float2&lt;/span> dir &lt;span style="color:#f92672">=&lt;/span> GetDirection(dispatchThreadId.xy, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> normalVS &lt;span style="color:#f92672">=&lt;/span> GetNormalVS(normalBufferData);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> sliceN &lt;span style="color:#f92672">=&lt;/span> normalize(cross(&lt;span style="color:#66d9ef">float3&lt;/span>(dir.xy, &lt;span style="color:#ae81ff">0.0f&lt;/span>), V.xyz));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> projN &lt;span style="color:#f92672">=&lt;/span> normalVS &lt;span style="color:#f92672">-&lt;/span> sliceN &lt;span style="color:#f92672">*&lt;/span> dot(normalVS, sliceN);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> projNLen &lt;span style="color:#f92672">=&lt;/span> length(projN);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> cosN &lt;span style="color:#f92672">=&lt;/span> dot(projN &lt;span style="color:#f92672">/&lt;/span> projNLen, V);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> cross(V, sliceN);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>sign(dot(projN, T)) &lt;span style="color:#f92672">*&lt;/span> GTAOFastAcos(cosN);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Find horizons&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float2&lt;/span> maxHorizons;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.x &lt;span style="color:#f92672">=&lt;/span> HorizonLoop(positionVS, V, rayStart, dir, offset, step, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.y &lt;span style="color:#f92672">=&lt;/span> HorizonLoop(positionVS, V, rayStart, negDir, offset, step, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Now we find the actual horizon angles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>GTAOFastAcos(maxHorizons.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.y &lt;span style="color:#f92672">=&lt;/span> GTAOFastAcos(maxHorizons.y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.x &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">+&lt;/span> max(maxHorizons.x &lt;span style="color:#f92672">-&lt;/span> N, &lt;span style="color:#f92672">-&lt;/span>HALF_PI);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizons.y &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">+&lt;/span> min(maxHorizons.y &lt;span style="color:#f92672">-&lt;/span> N, HALF_PI);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> integral &lt;span style="color:#f92672">+=&lt;/span> AnyIsNaN(maxHorizons) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> IntegrateArcCosWeighted(maxHorizons.x, maxHorizons.y, N, cosN);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>integral &lt;span style="color:#f92672">/=&lt;/span> dirCount;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For a given direction &lt;em>i&lt;/em>, the &lt;em>HorizonLoop()&lt;/em> function finds the maximum elevation for the right part of the hemisphere (&lt;em>maxHorizon.x&lt;/em>) and for the left part (&lt;em>maxHorizon.y&lt;/em>).&lt;/p>
&lt;p>With those maximum elevations, the algorithm then clamps the horizons to the hemisphere centered on the projected normal, and then computes the integral of the un-occluded regions on each side of the view vector using the &lt;em>IntegrateArcCosWeighted()&lt;/em> function.&lt;/p>
&lt;p>To use the visibility bitmask approach, we slightly modify the &lt;em>HorizonLoop()&lt;/em> function to pass an &lt;em>inout uint globalOccludedBitfield&lt;/em> that will be marked with occluded sectors.&lt;/p>
&lt;p>We can then compute the integral by counting the number of occluded sectors and dividing by the total amount of sectors. Note that we do not take the cosine weight into account in this case.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-hlsl" data-lang="hlsl">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Find horizons&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float2&lt;/span> maxHorizons;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">uint&lt;/span> globalOccludedBitfield &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxHorizons.x &lt;span style="color:#f92672">=&lt;/span> HorizonLoop(positionVS, V, rayStart, dir, offset, step, &lt;span style="color:#ae81ff">0&lt;/span>, globalOccludedBitfield, &lt;span style="color:#ae81ff">1&lt;/span>, N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxHorizons.y &lt;span style="color:#f92672">=&lt;/span> HorizonLoop(positionVS, V, rayStart, negDir, offset, step, &lt;span style="color:#ae81ff">0&lt;/span>, globalOccludedBitfield, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef VISIBILITY_BITMASK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> integral &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">float&lt;/span>(countbits(globalOccludedBitfield)) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">float&lt;/span>(SECTOR_COUNT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Now we find the actual horizon angles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Most of the work happens in the HorizonLoop() function. The GTAO implementation take a fixed number of samples (_&lt;em>AOStepCount&lt;/em>) along the current direction (&lt;em>rayDir&lt;/em>).&lt;/p>
&lt;p>For each sample found, the view space position is reconstructed (&lt;em>samplePosVS&lt;/em>), and the direction from the current pixel to the current sample is computed (&lt;em>deltaPos&lt;/em>). This is used to compute the elevation (&lt;em>currHorizon&lt;/em>). The &lt;em>UpdateHorizon()&lt;/em> function is used to apply a falloff over the distance and keep the highest found elevation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-hlsl" data-lang="hlsl">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> HorizonLoop(&lt;span style="color:#66d9ef">float3&lt;/span> positionVS, &lt;span style="color:#66d9ef">float3&lt;/span> V, &lt;span style="color:#66d9ef">float2&lt;/span> rayStart, &lt;span style="color:#66d9ef">float2&lt;/span> rayDir,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> rayOffset, &lt;span style="color:#66d9ef">float&lt;/span> rayStep, &lt;span style="color:#66d9ef">int&lt;/span> mipModifier)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> maxHorizon &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1.0f&lt;/span>; &lt;span style="color:#75715e">// cos(pi)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> rayOffset &lt;span style="color:#f92672">*&lt;/span> rayStep &lt;span style="color:#f92672">+&lt;/span> rayStep;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint&lt;/span> startWithLowerRes &lt;span style="color:#f92672">=&lt;/span> min(max(&lt;span style="color:#ae81ff">0&lt;/span>, _AOStepCount &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#ae81ff">3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> _AOStepCount; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float2&lt;/span> samplePos &lt;span style="color:#f92672">=&lt;/span> max(&lt;span style="color:#ae81ff">2&lt;/span>, min(rayStart &lt;span style="color:#f92672">+&lt;/span> t &lt;span style="color:#f92672">*&lt;/span> rayDir, _AOBufferSize.xy &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Find horizons at these steps:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> sampleDepth &lt;span style="color:#f92672">=&lt;/span> GetDepthSample(samplePos, i &lt;span style="color:#f92672">&amp;gt;&lt;/span> startWithLowerRes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> samplePosVS &lt;span style="color:#f92672">=&lt;/span> GetPositionVS(samplePos.xy, sampleDepth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> deltaPos &lt;span style="color:#f92672">=&lt;/span> samplePosVS &lt;span style="color:#f92672">-&lt;/span> positionVS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> deltaLenSq &lt;span style="color:#f92672">=&lt;/span> dot(deltaPos, deltaPos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> currHorizon &lt;span style="color:#f92672">=&lt;/span> dot(deltaPos, V) &lt;span style="color:#f92672">*&lt;/span> rsqrt(deltaLenSq);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizon &lt;span style="color:#f92672">=&lt;/span> UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t &lt;span style="color:#f92672">+=&lt;/span> rayStep;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> maxHorizon;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With visibility bitmasks things are a bit different; We need to compute not only the front-face sample (&lt;em>deltaPos&lt;/em>) but a back-face one too (&lt;em>deltaPosBackface&lt;/em>) that is determined by the constant thickness value used (_&lt;em>Thickness&lt;/em>).&lt;/p>
&lt;p>The horizon angles for front and back are computed, shifted from viewDir to normal and clamped in [0, 1] where 0 is the left side of the hemisphere, and 1 the right side. Then the &lt;em>UpdatePartitions()&lt;/em> function is used to set the bits that lay between the font and back angles in &lt;em>globalOccludedBitfield&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-hlsl" data-lang="hlsl">&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float3&lt;/span> deltaPos &lt;span style="color:#f92672">=&lt;/span> samplePosVS &lt;span style="color:#f92672">-&lt;/span> positionVS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef VISIBILITY_BITMASK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float2&lt;/span> frontBackHorizon;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float3&lt;/span> deltaPosBackface &lt;span style="color:#f92672">=&lt;/span> deltaPos &lt;span style="color:#f92672">-&lt;/span> V &lt;span style="color:#f92672">*&lt;/span> _Thickness;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Project sample onto the unit circle and compute the angle relative to V&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frontBackHorizon &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">float2&lt;/span>(dot(normalize(deltaPos), V), dot(normalize(deltaPosBackface), V));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frontBackHorizon &lt;span style="color:#f92672">=&lt;/span> GTAOFastAcos(frontBackHorizon);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Shift sample from V to normal, clamp in [0..1]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frontBackHorizon &lt;span style="color:#f92672">=&lt;/span> saturate(((samplingDirection &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>frontBackHorizon) &lt;span style="color:#f92672">-&lt;/span> N &lt;span style="color:#f92672">+&lt;/span> HALF_PI) &lt;span style="color:#f92672">/&lt;/span> PI);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Sampling direction inverts min/max angles&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frontBackHorizon &lt;span style="color:#f92672">=&lt;/span> samplingDirection &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> frontBackHorizon.yx &lt;span style="color:#f92672">:&lt;/span> frontBackHorizon.xy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> globalOccludedBitfield &lt;span style="color:#f92672">=&lt;/span> UpdatePartitions(frontBackHorizon.x, frontBackHorizon.y, globalOccludedBitfield);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> deltaLenSq &lt;span style="color:#f92672">=&lt;/span> dot(deltaPos, deltaPos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> currHorizon &lt;span style="color:#f92672">=&lt;/span> dot(deltaPos, V) &lt;span style="color:#f92672">*&lt;/span> rsqrt(deltaLenSq);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHorizon &lt;span style="color:#f92672">=&lt;/span> UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With visibility bitmasks the &lt;em>UpdateHorizon()&lt;/em> function from GTAO is not needed anymore, because we don&amp;rsquo;t need to apply any falloff! The constant thickness and the bitmask is enough to reproduce the attenuation over the distance in a plausible manner. It&amp;rsquo;s similar to ray tracing AO that doesn&amp;rsquo;t need any falloff heuristic either.&lt;/p>
&lt;p>The &lt;em>UpdateParitions()&lt;/em> function takes as input minHorizon and maxHorizon that represent the position in the hemisphere with a value between 0 and 1.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-hlsl" data-lang="hlsl">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define SECTOR_COUNT 32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">uint&lt;/span> UpdatePartitions(&lt;span style="color:#66d9ef">float&lt;/span> minHorizon, &lt;span style="color:#66d9ef">float&lt;/span> maxHorizon, &lt;span style="color:#66d9ef">uint&lt;/span> globalOccludedBitfield)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> startHorizonInt &lt;span style="color:#f92672">=&lt;/span> minHorizon &lt;span style="color:#f92672">*&lt;/span> SECTOR_COUNT;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> angleHorizonInt &lt;span style="color:#f92672">=&lt;/span> ceil((maxHorizon&lt;span style="color:#f92672">-&lt;/span>minHorizon) &lt;span style="color:#f92672">*&lt;/span> SECTOR_COUNT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> angleHorizonBitfield &lt;span style="color:#f92672">=&lt;/span> angleHorizonInt &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> (&lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span> &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> (SECTOR_COUNT&lt;span style="color:#f92672">-&lt;/span>angleHorizonInt)) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> currentOccludedBitfield &lt;span style="color:#f92672">=&lt;/span> angleHorizonBitfield &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> startHorizonInt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> globalOccludedBitfield &lt;span style="color:#f92672">|&lt;/span> currentOccludedBitfield;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sectors get activated from minHorizon to maxHorizon depending on the chosen rounding function:&lt;/p>
&lt;ul>
&lt;li>ceil: Sample needs to at least touch a sector to activate it&lt;/li>
&lt;li>round: Sample needs to cover at least half a sector to activate it&lt;/li>
&lt;li>floor: Sample needs to cover the entire sector to activate it&lt;/li>
&lt;/ul>
&lt;p>That&amp;rsquo;s it! That pretty much covers the essential parts related to ambient occlusion using visibility bimasks. We left out the GI and the ambient sampling parts, maybe for a later post!&lt;/p></description></item></channel></rss>