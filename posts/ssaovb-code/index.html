<!doctype html><html lang data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>SSAO using Visibility Bitmasks - CDRIN Research Blog</title><meta name=description content="We recently released the paper Screen Space Indirect Lighting with Visibility Bitmask, a rendering technique based on GTAO that replaces the two horizon angles by a bit field representing the binary state (occluded / un-occluded) of N sectors uniformly distributed around the hemisphere slice. It allows light to pass behind surfaces of constant thickness while keeping the efficiency of horizon-based methods.
We wanted to share some HLSL code to make it easier to implement in a 3D applications and clarify some details from the paper."><link rel=icon type=image/x-icon href=https://cdrinmatane.github.io/blog-hugo/favicon.ico><link rel=apple-touch-icon-precomposed href=https://cdrinmatane.github.io/blog-hugo/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=https://cdrinmatane.github.io/blog-hugo/css/style.min.9d45a7788214c244d5cb91d9d03f7b0ab4a36f0530b4f3708257638e33dea009.css integrity="sha256-nUWneIIUwkTVy5HZ0D97CrSjbwUwtPNwgldjjjPeoAk="><script src=https://cdrinmatane.github.io/blog-hugo/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js type=text/javascript integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script><meta property="og:title" content="SSAO using Visibility Bitmasks"><meta property="og:description" content="We recently released the paper Screen Space Indirect Lighting with Visibility Bitmask, a rendering technique based on GTAO that replaces the two horizon angles by a bit field representing the binary state (occluded / un-occluded) of N sectors uniformly distributed around the hemisphere slice. It allows light to pass behind surfaces of constant thickness while keeping the efficiency of horizon-based methods.
We wanted to share some HLSL code to make it easier to implement in a 3D applications and clarify some details from the paper."><meta property="og:type" content="article"><meta property="og:url" content="https://cdrinmatane.github.io/blog-hugo/posts/ssaovb-code/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-11T09:48:54-04:00"><meta property="article:modified_time" content="2023-05-11T09:48:54-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SSAO using Visibility Bitmasks"><meta name=twitter:description content="We recently released the paper Screen Space Indirect Lighting with Visibility Bitmask, a rendering technique based on GTAO that replaces the two horizon angles by a bit field representing the binary state (occluded / un-occluded) of N sectors uniformly distributed around the hemisphere slice. It allows light to pass behind surfaces of constant thickness while keeping the efficiency of horizon-based methods.
We wanted to share some HLSL code to make it easier to implement in a 3D applications and clarify some details from the paper."></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><div class=header-top><h1 class=site-title><a href=/blog-hugo>CDRIN Research Blog</a></h1><ul class=social-icons><li><a href=https://github.com/cdrinmatane title=Github rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></li><li><a href=https://cdrinmatane.github.io/blog-hugo/index.xml title=RSS rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg></span></a></li></ul></div><nav><a href=https://www.cdrin.com/ title>About</a>
<a href=https://cdrinmatane.github.io/blog-hugo/ title>Home</a>
<a href=https://cdrinmatane.github.io/blog-hugo/posts/ title>Archive</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">SSAO using Visibility Bitmasks</h1><div class=post-info><div class=meta_item><span class=meta_text>Olivier Therrien, Graphics R&amp;D Programmer</hspan></div><div class="post-date dt-published">2023-05-11</div><a class="post-hidden-url u-url" href=https://cdrinmatane.github.io/blog-hugo/posts/ssaovb-code/>https://cdrinmatane.github.io/blog-hugo/posts/ssaovb-code/</a>
<a href=https://cdrinmatane.github.io/blog-hugo/ class="p-name p-author post-hidden-author h-card" rel=me>therrieno</a><div class=post-taxonomies></div></div></header></div><div class="content e-content"><p>We recently released the paper <a href=https://arxiv.org/abs/2301.11376>Screen Space Indirect Lighting with Visibility Bitmask</a>, a rendering technique based on GTAO that replaces the two horizon angles by a bit field representing the binary state (occluded / un-occluded) of N sectors uniformly distributed around the hemisphere slice. It allows light to pass behind surfaces of constant thickness while keeping the efficiency of horizon-based methods.</p><p>We wanted to share some HLSL code to make it easier to implement in a 3D applications and clarify some details from the paper. Here we take the Unity GTAO code from HDRP as a starting point, to show that our method can be integrated in an existing implementation with only a few modifications.</p><p>The GTAO algorithm starts by taking a fixed number (<em>dirCount</em>) of random directions per pixel (<em>dir</em>). Then a 2D circular slice is defined with the following parametrization:</p><ul><li><em>V</em>: The view direction (direction from current pixel to camera)</li><li><em>normalVS</em>: The view-space normal at the current pixel</li><li><em>sliceN</em>: Unit vector that is perpendicular to the slice plane</li><li><em>projN</em>: The normal projected onto the slice plane (the normal is almost never aligned with the slice plane)</li><li><em>T</em>: The slice tangent (perpendicular to <em>V</em> and <em>sliceN</em>)</li><li><em>N</em>: The angle in radians from <em>V</em> to <em>projN</em></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hlsl data-lang=hlsl><span style=display:flex><span><span style=color:#66d9ef>float</span> integral <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> V <span style=color:#f92672>=</span> normalize(<span style=color:#f92672>-</span>positionVS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> dirCount; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> dir <span style=color:#f92672>=</span> GetDirection(dispatchThreadId.xy, i);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalVS <span style=color:#f92672>=</span> GetNormalVS(normalBufferData);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> sliceN <span style=color:#f92672>=</span> normalize(cross(<span style=color:#66d9ef>float3</span>(dir.xy, <span style=color:#ae81ff>0.0f</span>), V.xyz));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> projN <span style=color:#f92672>=</span> normalVS <span style=color:#f92672>-</span> sliceN <span style=color:#f92672>*</span> dot(normalVS, sliceN);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> projNLen <span style=color:#f92672>=</span> length(projN);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cosN <span style=color:#f92672>=</span> dot(projN <span style=color:#f92672>/</span> projNLen, V);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> T <span style=color:#f92672>=</span> cross(V, sliceN);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> N <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>sign(dot(projN, T)) <span style=color:#f92672>*</span> GTAOFastAcos(cosN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find horizons</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> maxHorizons;
</span></span><span style=display:flex><span>    maxHorizons.x <span style=color:#f92672>=</span> HorizonLoop(positionVS, V, rayStart, dir, offset, step, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    maxHorizons.y <span style=color:#f92672>=</span> HorizonLoop(positionVS, V, rayStart, negDir, offset, step, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now we find the actual horizon angles</span>
</span></span><span style=display:flex><span>    maxHorizons.x <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>GTAOFastAcos(maxHorizons.x);
</span></span><span style=display:flex><span>    maxHorizons.y <span style=color:#f92672>=</span> GTAOFastAcos(maxHorizons.y);
</span></span><span style=display:flex><span>    maxHorizons.x <span style=color:#f92672>=</span> N <span style=color:#f92672>+</span> max(maxHorizons.x <span style=color:#f92672>-</span> N, <span style=color:#f92672>-</span>HALF_PI);
</span></span><span style=display:flex><span>    maxHorizons.y <span style=color:#f92672>=</span> N <span style=color:#f92672>+</span> min(maxHorizons.y <span style=color:#f92672>-</span> N, HALF_PI);
</span></span><span style=display:flex><span>    integral <span style=color:#f92672>+=</span> AnyIsNaN(maxHorizons) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> IntegrateArcCosWeighted(maxHorizons.x, maxHorizons.y, N, cosN);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>integral <span style=color:#f92672>/=</span> dirCount;
</span></span></code></pre></div><p>For a given direction <em>i</em>, the <em>HorizonLoop()</em> function finds the maximum elevation for the right part of the hemisphere (<em>maxHorizon.x</em>) and for the left part (<em>maxHorizon.y</em>).</p><p>With those maximum elevations, the algorithm then clamps the horizons to the hemisphere centered on the projected normal, and then computes the integral of the un-occluded regions on each side of the view vector using the <em>IntegrateArcCosWeighted()</em> function.</p><p>To use the visibility bitmask approach, we slightly modify the <em>HorizonLoop()</em> function to pass an <em>inout uint globalOccludedBitfield</em> that will be marked with occluded sectors.</p><p>We can then compute the integral by counting the number of occluded sectors and dividing by the total amount of sectors. Note that we do not take the cosine weight into account in this case.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hlsl data-lang=hlsl><span style=display:flex><span><span style=color:#75715e>// Find horizons</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> maxHorizons;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> globalOccludedBitfield <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>maxHorizons.x <span style=color:#f92672>=</span> HorizonLoop(positionVS, V, rayStart, dir, offset, step, <span style=color:#ae81ff>0</span>, globalOccludedBitfield, <span style=color:#ae81ff>1</span>, N);
</span></span><span style=display:flex><span>maxHorizons.y <span style=color:#f92672>=</span> HorizonLoop(positionVS, V, rayStart, negDir, offset, step, <span style=color:#ae81ff>0</span>, globalOccludedBitfield, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, N);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef VISIBILITY_BITMASK</span>
</span></span><span style=display:flex><span>    integral <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> <span style=color:#66d9ef>float</span>(countbits(globalOccludedBitfield)) <span style=color:#f92672>/</span> <span style=color:#66d9ef>float</span>(SECTOR_COUNT);
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now we find the actual horizon angles</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><p>Most of the work happens in the HorizonLoop() function. The GTAO implementation take a fixed number of samples (_<em>AOStepCount</em>) along the current direction (<em>rayDir</em>).</p><p>For each sample found, the view space position is reconstructed (<em>samplePosVS</em>), and the direction from the current pixel to the current sample is computed (<em>deltaPos</em>). This is used to compute the elevation (<em>currHorizon</em>). The <em>UpdateHorizon()</em> function is used to apply a falloff over the distance and keep the highest found elevation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hlsl data-lang=hlsl><span style=display:flex><span><span style=color:#66d9ef>float</span> HorizonLoop(<span style=color:#66d9ef>float3</span> positionVS, <span style=color:#66d9ef>float3</span> V, <span style=color:#66d9ef>float2</span> rayStart, <span style=color:#66d9ef>float2</span> rayDir, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rayOffset, <span style=color:#66d9ef>float</span> rayStep, <span style=color:#66d9ef>int</span> mipModifier)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> maxHorizon <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>;  <span style=color:#75715e>// cos(pi)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> t <span style=color:#f92672>=</span> rayOffset <span style=color:#f92672>*</span> rayStep <span style=color:#f92672>+</span> rayStep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint</span> startWithLowerRes <span style=color:#f92672>=</span> min(max(<span style=color:#ae81ff>0</span>, _AOStepCount <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> _AOStepCount; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> samplePos <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>2</span>, min(rayStart <span style=color:#f92672>+</span> t <span style=color:#f92672>*</span> rayDir, _AOBufferSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find horizons at these steps:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sampleDepth <span style=color:#f92672>=</span> GetDepthSample(samplePos, i <span style=color:#f92672>&gt;</span> startWithLowerRes);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> samplePosVS <span style=color:#f92672>=</span> GetPositionVS(samplePos.xy, sampleDepth);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> deltaPos <span style=color:#f92672>=</span> samplePosVS <span style=color:#f92672>-</span> positionVS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> deltaLenSq <span style=color:#f92672>=</span> dot(deltaPos, deltaPos);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> currHorizon <span style=color:#f92672>=</span> dot(deltaPos, V) <span style=color:#f92672>*</span> rsqrt(deltaLenSq);
</span></span><span style=display:flex><span>        maxHorizon <span style=color:#f92672>=</span> UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        t <span style=color:#f92672>+=</span> rayStep;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> maxHorizon;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With visibility bitmasks things are a bit different; We need to compute not only the front-face sample (<em>deltaPos</em>) but a back-face one too (<em>deltaPosBackface</em>) that is determined by the constant thickness value used (_<em>Thickness</em>).</p><p>The horizon angles for front and back are computed, shifted from viewDir to normal and clamped in [0, 1] where 0 is the left side of the hemisphere, and 1 the right side. Then the <em>UpdatePartitions()</em> function is used to set the bits that lay between the font and back angles in <em>globalOccludedBitfield</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hlsl data-lang=hlsl><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> deltaPos <span style=color:#f92672>=</span> samplePosVS <span style=color:#f92672>-</span> positionVS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef VISIBILITY_BITMASK</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> frontBackHorizon;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> deltaPosBackface <span style=color:#f92672>=</span> deltaPos <span style=color:#f92672>-</span> V <span style=color:#f92672>*</span> _Thickness;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Project sample onto the unit circle and compute the angle relative to V</span>
</span></span><span style=display:flex><span>    frontBackHorizon <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(dot(normalize(deltaPos), V), dot(normalize(deltaPosBackface), V));
</span></span><span style=display:flex><span>    frontBackHorizon <span style=color:#f92672>=</span> GTAOFastAcos(frontBackHorizon);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Shift sample from V to normal, clamp in [0..1]</span>
</span></span><span style=display:flex><span>    frontBackHorizon <span style=color:#f92672>=</span> saturate(((samplingDirection <span style=color:#f92672>*</span> <span style=color:#f92672>-</span>frontBackHorizon) <span style=color:#f92672>-</span> N <span style=color:#f92672>+</span> HALF_PI) <span style=color:#f92672>/</span> PI);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sampling direction inverts min/max angles</span>
</span></span><span style=display:flex><span>    frontBackHorizon <span style=color:#f92672>=</span> samplingDirection <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> frontBackHorizon.yx <span style=color:#f92672>:</span> frontBackHorizon.xy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    globalOccludedBitfield <span style=color:#f92672>=</span> UpdatePartitions(frontBackHorizon.x, frontBackHorizon.y, globalOccludedBitfield);
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> deltaLenSq <span style=color:#f92672>=</span> dot(deltaPos, deltaPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> currHorizon <span style=color:#f92672>=</span> dot(deltaPos, V) <span style=color:#f92672>*</span> rsqrt(deltaLenSq);
</span></span><span style=display:flex><span>    maxHorizon <span style=color:#f92672>=</span> UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><p>With visibility bitmasks the <em>UpdateHorizon()</em> function from GTAO is not needed anymore, because we don&rsquo;t need to apply any falloff! The constant thickness and the bitmask is enough to reproduce the attenuation over the distance in a plausible manner. It&rsquo;s similar to ray tracing AO that doesn&rsquo;t need any falloff heuristic either.</p><p>The <em>UpdateParitions()</em> function takes as input minHorizon and maxHorizon that represent the position in the hemisphere with a value between 0 and 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hlsl data-lang=hlsl><span style=display:flex><span><span style=color:#75715e>#define SECTOR_COUNT 32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> UpdatePartitions(<span style=color:#66d9ef>float</span> minHorizon, <span style=color:#66d9ef>float</span> maxHorizon, <span style=color:#66d9ef>uint</span> globalOccludedBitfield)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> startHorizonInt <span style=color:#f92672>=</span> minHorizon <span style=color:#f92672>*</span> SECTOR_COUNT;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> angleHorizonInt <span style=color:#f92672>=</span> ceil((maxHorizon<span style=color:#f92672>-</span>minHorizon) <span style=color:#f92672>*</span> SECTOR_COUNT);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> angleHorizonBitfield <span style=color:#f92672>=</span> angleHorizonInt <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> (<span style=color:#ae81ff>0xFFFFFFFF</span> <span style=color:#f92672>&gt;&gt;</span> (SECTOR_COUNT<span style=color:#f92672>-</span>angleHorizonInt)) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> currentOccludedBitfield <span style=color:#f92672>=</span> angleHorizonBitfield <span style=color:#f92672>&lt;&lt;</span> startHorizonInt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> globalOccludedBitfield <span style=color:#f92672>|</span> currentOccludedBitfield;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sectors get activated from minHorizon to maxHorizon depending on the chosen rounding function:</p><ul><li>ceil: Sample needs to at least touch a sector to activate it</li><li>round: Sample needs to cover at least half a sector to activate it</li><li>floor: Sample needs to cover the entire sector to activate it</li></ul><p>That&rsquo;s it! That pretty much covers the essential parts related to ambient occlusion using visibility bimasks. We left out the GI and the ambient sampling parts, maybe for a later post!</p></div></article></main><footer class=common-footer><div class=common-footer-bottom><div class=copyright><p>Â© CDRIN, 2023<br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div><button class=theme-switcher>
Dark theme</button>
<script>const STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeButtonText()};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),switchButton&&(changeButtonText(),switchButton.addEventListener("click",switchTheme,!1)),showContent()});function detectCurrentScheme(){return localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function changeButtonText(e){e&&(e.textContent=currentTheme=="dark"?"Light theme":"Dark theme")}function switchTheme(){currentTheme=="dark"?(localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark"),changeButtonText()}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}</script></div><p class="h-card vcard"><a href=https://cdrinmatane.github.io/blog-hugo/ class="p-name u-url url fn" rel=me>CDRIN</a></p></footer></div></body></html>